#ifndef BINOMIAL_QUEUE_H
#define BINOMIAL_QUEUE_H
#include "../common/item_int.h"
/*

  堆定义 所要求的条件 和 堆有序的二叉树 要求的条件都太强了, 所以限制很多,
当进行join操作时, 不能高效实现.
  所以需要一些削弱了这些条件的高级数据结构, 才能实现高效的join操作.
  binomial queue 二项队列.

    2次幂堆. 2项树.

  如果1 一颗二叉树 2每个节点的关键字大于或等于该节点的左子树的所有关键字, 称为左有序堆。
  如果1 一颗左有序堆 2 右子树为空, 左子树为完全二叉树(是左有序堆), 称为2次幂堆，右兄弟为二项树??

  二项队列 是 2次幂堆的集合, 其中不存在大小相等的堆。
    二项队列的结构是由那个队列的节点数目确定的, 对应整数的二进制表示.
    2次幂堆的集合.
    eg 二进制1010(10) 代表由四个2次幂堆构成,
        最高位1 代表8节点2次幂堆 存在
        次高位0 代表4节点2次幂堆 不存在
        次低位1 代表2节点2次幂堆 存在
        最低位0 代表1节点2次幂堆 不存在
        总共10个节点, 两个2次幂堆.
        正好是一个整数的二进制表示, 位数对应代表2次幂堆节点数, 01 代表是否存在.


*/

/*
    优先队列ADT的所有操作 使用二项队列都可以实现, 并且在N个数据的队列上执行的任何操作(insert delmax join)
 需要的操作都<= O(lgN).
    O(lgN)的性能要求界限 是设计数据结构的目标.
二项队列提供了一种快速性能保证, 但如果对于某些操作有保证的常量时间的性能, 所涉及的数据结构就有更好的理论特征. 另一方面 有些深奥的数据结构的实用性收到怀疑,

在深入研究 复杂数据结构解决方法 之前， 可以通过降低某些优先队列操作的运行时间来改进性能.
    实际上除非需要大量快读join操作, 否则一般情况下我们实现优先队列的步骤
    1 我们一般会选择使用简单结构对小规模数据进行调试,
    2 然后使用堆结构来加速操作.
    3 最后我们应该使用二项队列来保证所有操作的 对数时间复杂度性能.
    所以考虑所有实现优先队列的结构, 基于二项队列的优先队列、基于堆的优先队列 绝对是值得加入到个人软件包中的.
 */
#define test(C, B, A) 4*(C) + 2*(B) + 1*(A)

struct binomial_queue{
    bq_link *bq;
};

struct bq_node;
typedef struct bq_node* bq_link;

bq_link pair(bq_link p, bq_link q);
bq_link bq_insert(binomial_queue *bin_q, Item v);
bq_link bq_delmax(binomial_queue *bin_q);
void    bq_join(binomial_queue *a, binomial_queue *b);
#endif // BINOMIAL_QUEUE_H
